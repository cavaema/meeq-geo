const express = require('express');
const sqlite3 = require('sqlite3').verbose();
const nodemailer = require('nodemailer');
const jwt = require('jsonwebtoken');
const cors = require('cors');
const path = require('path');

const app = express();
const PORT = 3000;
const JWT_SECRET = 'meeq-secret-key-change-in-production-' + Date.now();
const ADMIN_USERNAME = 'admin';
const ADMIN_PASSWORD = 'meeq2024';

app.use(cors());
app.use(express.json());
app.use(express.static('public'));

app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

app.get('/admin', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'admin.html'));
});

const db = new sqlite3.Database('./chat.db', (err) => {
  if (err) {
    console.error('âŒ Errore apertura database:', err);
  } else {
    console.log('âœ… Database connesso');
  }
});

db.serialize(() => {
  db.run(`CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nome TEXT NOT NULL,
    cognome TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    telefono TEXT,
    tavolo TEXT,
    logged_in INTEGER DEFAULT 0,
    privacy_accepted INTEGER DEFAULT 0,
    newsletter_accepted INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_login DATETIME,
    last_activity DATETIME DEFAULT CURRENT_TIMESTAMP
  )`);

  db.run(`CREATE TABLE IF NOT EXISTS pending_registrations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT NOT NULL,
    nome TEXT NOT NULL,
    cognome TEXT NOT NULL,
    telefono TEXT,
    pin TEXT NOT NULL,
    privacy_accepted INTEGER DEFAULT 0,
    newsletter_accepted INTEGER DEFAULT 0,
    expires_at DATETIME NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )`);

  db.run(`CREATE TABLE IF NOT EXISTS rooms (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT
  )`);

  db.run(`CREATE TABLE IF NOT EXISTS messages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    sender_id INTEGER NOT NULL,
    recipient_id INTEGER NOT NULL,
    message TEXT NOT NULL,
    is_anonymous INTEGER DEFAULT 1,
    identity_revealed INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (sender_id) REFERENCES users(id),
    FOREIGN KEY (recipient_id) REFERENCES users(id)
  )`);

  db.run(`CREATE TABLE IF NOT EXISTS conversations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user1_id INTEGER NOT NULL,
    user2_id INTEGER NOT NULL,
    status TEXT DEFAULT 'pending',
    user1_revealed INTEGER DEFAULT 0,
    user2_revealed INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user1_id) REFERENCES users(id),
    FOREIGN KEY (user2_id) REFERENCES users(id),
    UNIQUE(user1_id, user2_id)
  )`);

  const tables = [];
  for (let i = 1; i <= 30; i++) {
    tables.push(`('tavolo-${i}', 'Tavolo ${i}', 'Tavolo numero ${i}')`);
  }
  tables.push(`('generale', 'Chat Generale', 'Chat pubblica per tutti')`);
  
  db.run(`INSERT OR IGNORE INTO rooms (id, name, description) VALUES ${tables.join(', ')}`);
});

const transporter = nodemailer.createTransport({
  host: 'authsmtp.securemail.pro',
  port: 465,
  secure: true,
  auth: {
    user: 'info@meeq.it',
    pass: 'Flw25mq!'
  }
});

function generatePin() {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Token mancante' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Token non valido' });
    }
    req.user = user;
    
    db.run('UPDATE users SET last_activity = CURRENT_TIMESTAMP WHERE id = ?', [user.userId]);
    
    next();
  });
}
app.post('/api/check-email', (req, res) => {
  const { email } = req.body;

  if (!email) {
    return res.status(400).json({ error: 'Email richiesta' });
  }

  db.get('SELECT id, nome, cognome FROM users WHERE email = ?', [email], (err, user) => {
    if (err) {
      console.error('Errore check email:', err);
      return res.status(500).json({ error: 'Errore server' });
    }

    if (user) {
      const pin = generatePin();
      const expiresAt = new Date(Date.now() + 10 * 60000).toISOString();

      db.run('DELETE FROM pending_registrations WHERE email = ?', [email], (deleteErr) => {
        if (deleteErr) {
          console.error('Errore eliminazione pending:', deleteErr);
          return res.status(500).json({ error: 'Errore server' });
        }

        db.run(
          `INSERT INTO pending_registrations (email, nome, cognome, telefono, pin, privacy_accepted, newsletter_accepted, expires_at) 
           VALUES (?, ?, ?, '', ?, 1, 0, ?)`,
          [email, user.nome, user.cognome, pin, expiresAt],
          (insertErr) => {
            if (insertErr) {
              console.error('Errore inserimento pending:', insertErr);
              return res.status(500).json({ error: 'Errore server' });
            }

            const mailOptions = {
              from: '"Meeq" <info@meeq.it>',
              to: email,
              subject: 'Il tuo codice PIN per Meeq',
              html: `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                  <h2 style="color: #E91E8C;">Benvenuto su Meeq!</h2>
                  <p>Ciao <strong>${user.nome}</strong>,</p>
                  <p>Il tuo codice PIN per accedere Ã¨:</p>
                  <div style="background: #f5f5f5; padding: 20px; text-align: center; font-size: 32px; font-weight: bold; color: #8B5CF6; margin: 20px 0;">
                    ${pin}
                  </div>
                  <p style="color: #666; font-size: 14px;">Il codice scade tra 10 minuti.</p>
                  <p style="margin-top: 30px; color: #999; font-size: 12px;">
                    Connetti. Scopri. Gioca.<br>
                    - Il team Meeq
                  </p>
                </div>
              `
            };

            transporter.sendMail(mailOptions, (mailErr) => {
              if (mailErr) {
                console.error('Errore invio email:', mailErr);
                return res.status(500).json({ error: 'Errore invio email' });
              }

              console.log(`âœ‰ï¸  PIN inviato a ${email}: ${pin}`);
              res.json({ 
                exists: true, 
                message: 'PIN inviato via email',
                isReturningUser: true 
              });
            });
          }
        );
      });
    } else {
      res.json({ exists: false });
    }
  });
});

app.post('/api/register', (req, res) => {
  const { nome, cognome, email, telefono, privacyAccepted, newsletterAccepted } = req.body;

  if (!nome || !cognome || !email || !privacyAccepted) {
    return res.status(400).json({ error: 'Campi obbligatori mancanti' });
  }

  const pin = generatePin();
  const expiresAt = new Date(Date.now() + 10 * 60000).toISOString();

  db.run('DELETE FROM pending_registrations WHERE email = ?', [email], (deleteErr) => {
    if (deleteErr) {
      console.error('Errore eliminazione pending:', deleteErr);
      return res.status(500).json({ error: 'Errore server' });
    }

    db.run(
      `INSERT INTO pending_registrations (email, nome, cognome, telefono, pin, privacy_accepted, newsletter_accepted, expires_at) 
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [email, nome, cognome, telefono || '', pin, privacyAccepted ? 1 : 0, newsletterAccepted ? 1 : 0, expiresAt],
      function(insertErr) {
        if (insertErr) {
          console.error('Errore salvataggio dati:', insertErr);
          return res.status(500).json({ error: 'Errore salvataggio dati' });
        }

        const mailOptions = {
          from: '"Meeq" <info@meeq.it>',
          to: email,
          subject: 'Il tuo codice PIN per Meeq',
          html: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <h2 style="color: #E91E8C;">Benvenuto su Meeq!</h2>
              <p>Ciao <strong>${nome}</strong>,</p>
              <p>Il tuo codice PIN per accedere Ã¨:</p>
              <div style="background: #f5f5f5; padding: 20px; text-align: center; font-size: 32px; font-weight: bold; color: #8B5CF6; margin: 20px 0;">
                ${pin}
              </div>
              <p style="color: #666; font-size: 14px;">Il codice scade tra 10 minuti.</p>
              <p style="margin-top: 30px; color: #999; font-size: 12px;">
                Connetti. Scopri. Gioca.<br>
                - Il team Meeq
              </p>
            </div>
          `
        };

        transporter.sendMail(mailOptions, (mailErr) => {
          if (mailErr) {
            console.error('Errore invio email:', mailErr);
            return res.status(500).json({ error: 'Errore invio email' });
          }

          console.log(`âœ‰ï¸  PIN inviato a ${email}: ${pin}`);
          res.json({ message: 'PIN inviato via email' });
        });
      }
    );
  });
});
app.post('/api/verify-pin', (req, res) => {
  const { email, pin, tavolo } = req.body;

  if (!email || !pin) {
    return res.status(400).json({ error: 'Email e PIN richiesti' });
  }

  db.get(
    'SELECT * FROM pending_registrations WHERE email = ? AND pin = ? AND expires_at > datetime("now")',
    [email, pin],
    (err, pending) => {
      if (err) {
        console.error('Errore verifica PIN:', err);
        return res.status(500).json({ error: 'Errore server' });
      }

      if (!pending) {
        return res.status(400).json({ error: 'PIN non valido o scaduto' });
      }

      db.get('SELECT id FROM users WHERE email = ?', [email], (err, existingUser) => {
        if (err) {
          console.error('Errore controllo utente:', err);
          return res.status(500).json({ error: 'Errore server' });
        }

        const now = new Date().toISOString();
        const tavoloAssegnato = tavolo || pending.tavolo || null;

        if (existingUser) {
          db.run(
            'UPDATE users SET logged_in = 1, tavolo = ?, last_login = ?, last_activity = ? WHERE id = ?',
            [tavoloAssegnato, now, now, existingUser.id],
            (updateErr) => {
              if (updateErr) {
                console.error('Errore aggiornamento utente:', updateErr);
                return res.status(500).json({ error: 'Errore aggiornamento' });
              }

              db.run('DELETE FROM pending_registrations WHERE email = ?', [email]);

              const token = jwt.sign(
                { userId: existingUser.id, email: email },
                JWT_SECRET,
                { expiresIn: '24h' }
              );

              console.log(`âœ… Re-login: ${email} (ID: ${existingUser.id})`);
              res.json({
                message: 'Login effettuato',
                token: token,
                userId: existingUser.id,
                tavolo: tavoloAssegnato
              });
            }
          );
        } else {
          db.run(
            `INSERT INTO users (nome, cognome, email, telefono, tavolo, logged_in, privacy_accepted, newsletter_accepted, last_login, last_activity)
             VALUES (?, ?, ?, ?, ?, 1, ?, ?, ?, ?)`,
            [pending.nome, pending.cognome, email, pending.telefono, tavoloAssegnato, pending.privacy_accepted, pending.newsletter_accepted, now, now],
            function(insertErr) {
              if (insertErr) {
                console.error('Errore creazione utente:', insertErr);
                return res.status(500).json({ error: 'Errore registrazione' });
              }

              const userId = this.lastID;

              db.run('DELETE FROM pending_registrations WHERE email = ?', [email]);

              const token = jwt.sign(
                { userId: userId, email: email },
                JWT_SECRET,
                { expiresIn: '24h' }
              );

              console.log(`âœ… Nuovo utente registrato: ${email} (ID: ${userId})`);
              res.json({
                message: 'Registrazione completata',
                token: token,
                userId: userId,
                tavolo: tavoloAssegnato
              });
            }
          );
        }
      });
    }
  );
});

app.get('/api/verify-session', authenticateToken, (req, res) => {
  db.get('SELECT id, nome, cognome, email, tavolo FROM users WHERE id = ? AND logged_in = 1', 
    [req.user.userId], 
    (err, user) => {
      if (err) {
        console.error('Errore verifica sessione:', err);
        return res.status(500).json({ error: 'Errore server' });
      }

      if (!user) {
        return res.status(401).json({ error: 'Sessione non valida' });
      }

      res.json({
        valid: true,
        user: {
          id: user.id,
          nome: user.nome,
          cognome: user.cognome,
          email: user.email,
          tavolo: user.tavolo
        }
      });
    }
  );
});

app.post('/api/logout', authenticateToken, (req, res) => {
  db.run('UPDATE users SET logged_in = 0 WHERE id = ?', [req.user.userId], (err) => {
    if (err) {
      console.error('Errore logout:', err);
      return res.status(500).json({ error: 'Errore logout' });
    }

    console.log(`ðŸ‘‹ Logout utente ID: ${req.user.userId}`);
    res.json({ message: 'Logout effettuato' });
  });
});

app.get('/api/user/profile', authenticateToken, (req, res) => {
  db.get('SELECT id, nome, cognome, email, telefono, tavolo FROM users WHERE id = ?', 
    [req.user.userId], 
    (err, user) => {
      if (err) {
        console.error('Errore recupero profilo:', err);
        return res.status(500).json({ error: 'Errore server' });
      }

      if (!user) {
        return res.status(404).json({ error: 'Utente non trovato' });
      }

      res.json(user);
    }
  );
});

app.get('/api/tables/active', authenticateToken, (req, res) => {
  const query = `
    SELECT 
      r.id as room_id,
      r.name as room_name,
      COUNT(CASE WHEN u.id IS NOT NULL THEN 1 END) as user_count
    FROM rooms r
    LEFT JOIN users u ON r.id = 'tavolo-' || u.tavolo AND u.logged_in = 1 
      AND datetime(u.last_activity, '+30 minutes') > datetime('now')
    WHERE r.id != 'generale'
    GROUP BY r.id, r.name
    HAVING user_count > 0
    ORDER BY CAST(SUBSTR(r.id, 8) AS INTEGER)
  `;

  db.all(query, [], (err, tables) => {
    if (err) {
      console.error('Errore recupero tavoli:', err);
      return res.status(500).json({ error: 'Errore server' });
    }

    res.json(tables || []);
  });
});

app.get('/api/tables/:tableId/users', authenticateToken, (req, res) => {
  const tableId = req.params.tableId;
  const tableNumber = tableId.replace('tavolo-', '');

  const query = `
    SELECT id, nome, cognome, email 
    FROM users 
    WHERE tavolo = ? 
      AND logged_in = 1 
      AND datetime(last_activity, '+30 minutes') > datetime('now')
      AND id != ?
  `;

  db.all(query, [tableNumber, req.user.userId], (err, users) => {
    if (err) {
      console.error('Errore recupero utenti tavolo:', err);
      return res.status(500).json({ error: 'Errore server' });
    }

    res.json(users || []);
  });
});
app.get('/api/conversations', authenticateToken, (req, res) => {
  const query = `
    SELECT 
      c.id,
      c.user1_id,
      c.user2_id,
      c.status,
      c.user1_revealed,
      c.user2_revealed,
      c.created_at,
      c.updated_at,
      c.initiator_id,
      CASE 
        WHEN c.user1_id = ? THEN c.user2_id 
        ELSE c.user1_id 
      END as other_user_id,
      CASE 
        WHEN c.user1_id = ? THEN u2.nome 
        ELSE u1.nome 
      END as other_user_nome,
      CASE 
        WHEN c.user1_id = ? THEN u2.cognome 
        ELSE u1.cognome 
      END as other_user_cognome,
      CASE 
        WHEN c.user1_id = ? THEN u2.tavolo 
        ELSE u1.tavolo 
      END as other_user_tavolo,
      CASE 
        WHEN c.user1_id = ? THEN c.user2_revealed 
        ELSE c.user1_revealed 
      END as other_user_revealed,
      (SELECT COUNT(*) FROM messages m 
       WHERE (m.sender_id = CASE WHEN c.user1_id = ? THEN c.user2_id ELSE c.user1_id END 
              AND m.recipient_id = ?) 
       OR (m.sender_id = ? 
           AND m.recipient_id = CASE WHEN c.user1_id = ? THEN c.user2_id ELSE c.user1_id END)
      ) as message_count,
      (SELECT COUNT(*) FROM messages m 
       WHERE m.recipient_id = ? 
       AND m.sender_id = CASE WHEN c.user1_id = ? THEN c.user2_id ELSE c.user1_id END
       AND m.is_read = 0
      ) as unread_count
    FROM conversations c
    JOIN users u1 ON c.user1_id = u1.id
    JOIN users u2 ON c.user2_id = u2.id
    WHERE c.user1_id = ? OR c.user2_id = ?
    ORDER BY c.updated_at DESC
  `;

  db.all(query, [
    req.user.userId, req.user.userId, req.user.userId, req.user.userId, 
    req.user.userId, req.user.userId, req.user.userId, req.user.userId,
    req.user.userId, req.user.userId, req.user.userId,
    req.user.userId, req.user.userId  // ðŸ”¥ MOD 2: parametri per unread_count
  ], (err, conversations) => {
    if (err) {
      console.error('Errore recupero conversazioni:', err);
      return res.status(500).json({ error: 'Errore server' });
    }

    res.json(conversations || []);
  });
});

// ðŸ”¥ MOD 2: Endpoint per contare TUTTI i messaggi non letti dell'utente
app.get('/api/messages/unread-count', authenticateToken, (req, res) => {
  db.get(
    'SELECT COUNT(*) as count FROM messages WHERE recipient_id = ? AND is_read = 0',
    [req.user.userId],
    (err, result) => {
      if (err) {
        console.error('Errore conteggio messaggi non letti:', err);
        return res.status(500).json({ error: 'Errore server' });
      }
      res.json({ unreadCount: result.count });
    }
  );
});

app.post('/api/conversations', authenticateToken, (req, res) => {
  const { recipientId } = req.body;
  const senderId = req.user.userId;

  if (!recipientId) {
    return res.status(400).json({ error: 'Destinatario richiesto' });
  }

  if (recipientId === senderId) {
    return res.status(400).json({ error: 'Non puoi chattare con te stesso' });
  }

  const user1Id = Math.min(senderId, recipientId);
  const user2Id = Math.max(senderId, recipientId);

  // Controlla se conversazione esiste giÃ 
  db.get(
    'SELECT id FROM conversations WHERE user1_id = ? AND user2_id = ?',
    [user1Id, user2Id],
    (err, existing) => {
      if (err) {
        console.error('Errore controllo conversazione:', err);
        return res.status(500).json({ error: 'Errore server' });
      }

      if (existing) {
        // Recupera conversazione completa con tutti i campi
        const query = `
          SELECT 
            c.id,
            c.user1_id,
            c.user2_id,
            c.status,
            c.user1_revealed,
            c.user2_revealed,
            c.created_at,
            c.updated_at,
            c.initiator_id,
            CASE 
              WHEN c.user1_id = ? THEN c.user2_id 
              ELSE c.user1_id 
            END as other_user_id,
            CASE 
              WHEN c.user1_id = ? THEN u2.nome 
              ELSE u1.nome 
            END as other_user_nome,
            CASE 
              WHEN c.user1_id = ? THEN u2.cognome 
              ELSE u1.cognome 
            END as other_user_cognome,
            CASE 
              WHEN c.user1_id = ? THEN u2.tavolo 
              ELSE u1.tavolo 
            END as other_user_tavolo,
            CASE 
              WHEN c.user1_id = ? THEN c.user2_revealed 
              ELSE c.user1_revealed 
            END as other_user_revealed,
            (SELECT COUNT(*) FROM messages m 
             WHERE (m.sender_id = CASE WHEN c.user1_id = ? THEN c.user2_id ELSE c.user1_id END 
                    AND m.recipient_id = ?) 
             OR (m.sender_id = ? 
                 AND m.recipient_id = CASE WHEN c.user1_id = ? THEN c.user2_id ELSE c.user1_id END)
            ) as message_count
          FROM conversations c
          JOIN users u1 ON c.user1_id = u1.id
          JOIN users u2 ON c.user2_id = u2.id
          WHERE c.id = ?
        `;
        
        db.get(query, [
          senderId, senderId, senderId, senderId, senderId,
          senderId, senderId, senderId, senderId, existing.id
        ], (getErr, conversation) => {
          if (getErr) {
            console.error('Errore recupero conversazione esistente:', getErr);
            return res.status(500).json({ error: 'Errore server' });
          }
          return res.json({ conversation });
        });
        return;
      }

      db.run(
        `INSERT INTO conversations (user1_id, user2_id, status, user1_revealed, user2_revealed, initiator_id) 
         VALUES (?, ?, 'pending', 0, 0, ?)`,
        [user1Id, user2Id, senderId],
        function(insertErr) {
          if (insertErr) {
            console.error('Errore creazione conversazione:', insertErr);
            return res.status(500).json({ error: 'Errore creazione conversazione' });
          }

          // Recupera conversazione completa con tutti i campi calcolati
          const conversationId = this.lastID;
          const query = `
            SELECT 
              c.id,
              c.user1_id,
              c.user2_id,
              c.status,
              c.user1_revealed,
              c.user2_revealed,
              c.created_at,
              c.updated_at,
              c.initiator_id,
              CASE 
                WHEN c.user1_id = ? THEN c.user2_id 
                ELSE c.user1_id 
              END as other_user_id,
              CASE 
                WHEN c.user1_id = ? THEN u2.nome 
                ELSE u1.nome 
              END as other_user_nome,
              CASE 
                WHEN c.user1_id = ? THEN u2.cognome 
                ELSE u1.cognome 
              END as other_user_cognome,
              CASE 
                WHEN c.user1_id = ? THEN u2.tavolo 
                ELSE u1.tavolo 
              END as other_user_tavolo,
              CASE 
                WHEN c.user1_id = ? THEN c.user2_revealed 
                ELSE c.user1_revealed 
              END as other_user_revealed,
              0 as message_count
            FROM conversations c
            JOIN users u1 ON c.user1_id = u1.id
            JOIN users u2 ON c.user2_id = u2.id
            WHERE c.id = ?
          `;
          
          db.get(query, [
            senderId, senderId, senderId, senderId, senderId, conversationId
          ], (getErr, conversation) => {
            if (getErr) {
              console.error('Errore recupero conversazione:', getErr);
              return res.status(500).json({ error: 'Errore server' });
            }

            res.json({ conversation });
          });
        }
      );
    }
  );
});

app.patch('/api/conversations/:conversationId', authenticateToken, (req, res) => {
  const { conversationId } = req.params;
  const { status } = req.body;

  if (!['accepted', 'blocked'].includes(status)) {
    return res.status(400).json({ error: 'Stato non valido' });
  }

  db.run(
    'UPDATE conversations SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ? AND (user1_id = ? OR user2_id = ?)',
    [status, conversationId, req.user.userId, req.user.userId],
    function(err) {
      if (err) {
        console.error('Errore aggiornamento conversazione:', err);
        return res.status(500).json({ error: 'Errore server' });
      }

      if (this.changes === 0) {
        return res.status(404).json({ error: 'Conversazione non trovata' });
      }

      res.json({ message: 'Conversazione aggiornata', status });
    }
  );
});

app.post('/api/conversations/:conversationId/reveal', authenticateToken, (req, res) => {
  const { conversationId } = req.params;

  db.get(
    'SELECT user1_id, user2_id FROM conversations WHERE id = ?',
    [conversationId],
    (err, conversation) => {
      if (err) {
        console.error('Errore recupero conversazione:', err);
        return res.status(500).json({ error: 'Errore server' });
      }

      if (!conversation) {
        return res.status(404).json({ error: 'Conversazione non trovata' });
      }

      const isUser1 = conversation.user1_id === req.user.userId;
      const isUser2 = conversation.user2_id === req.user.userId;

      if (!isUser1 && !isUser2) {
        return res.status(403).json({ error: 'Non autorizzato' });
      }

      const fieldToUpdate = isUser1 ? 'user1_revealed' : 'user2_revealed';

      db.run(
        `UPDATE conversations SET ${fieldToUpdate} = 1, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
        [conversationId],
        function(updateErr) {
          if (updateErr) {
            console.error('Errore rivelazione identitÃ :', updateErr);
            return res.status(500).json({ error: 'Errore server' });
          }

          res.json({ message: 'IdentitÃ  rivelata' });
        }
      );
    }
  );
});

app.post('/api/messages', authenticateToken, (req, res) => {
  const { recipientId, message, conversationId } = req.body;

  if (!recipientId || !message) {
    return res.status(400).json({ error: 'Destinatario e messaggio richiesti' });
  }

  const user1Id = Math.min(req.user.userId, recipientId);
  const user2Id = Math.max(req.user.userId, recipientId);

  db.get(
    'SELECT id, status, initiator_id FROM conversations WHERE user1_id = ? AND user2_id = ?',
    [user1Id, user2Id],
    (err, conversation) => {
      if (err) {
        console.error('Errore verifica conversazione:', err);
        return res.status(500).json({ error: 'Errore server' });
      }

      if (!conversation) {
        return res.status(400).json({ error: 'Conversazione non trovata' });
      }

      // ðŸ”¥ MOD 1: Permetti invio se accepted O se pending + sei initiator
      const isInitiator = conversation.initiator_id === req.user.userId;
      const canSend = conversation.status === 'accepted' || 
                      (conversation.status === 'pending' && isInitiator);
      
      if (!canSend) {
        return res.status(400).json({ error: 'Non puoi inviare messaggi in questa conversazione' });
      }

      db.run(
        'INSERT INTO messages (sender_id, recipient_id, message, is_read) VALUES (?, ?, ?, 0)',
        [req.user.userId, recipientId, message],
        function(insertErr) {
          if (insertErr) {
            console.error('Errore invio messaggio:', insertErr);
            return res.status(500).json({ error: 'Errore invio messaggio' });
          }

          db.run(
            'UPDATE conversations SET updated_at = CURRENT_TIMESTAMP WHERE id = ?',
            [conversation.id]
          );

          res.json({
            message: 'Messaggio inviato',
            messageId: this.lastID
          });
        }
      );
    }
  );
});

app.get('/api/conversations/:conversationId/messages', authenticateToken, (req, res) => {
  const { conversationId } = req.params;

  db.get(
    'SELECT user1_id, user2_id, user1_revealed, user2_revealed, status, initiator_id FROM conversations WHERE id = ?',
    [conversationId],
    (err, conversation) => {
      if (err) {
        console.error('Errore verifica conversazione:', err);
        return res.status(500).json({ error: 'Errore server' });
      }

      if (!conversation) {
        return res.status(404).json({ error: 'Conversazione non trovata' });
      }

      const isUser1 = conversation.user1_id === req.user.userId;
      const isUser2 = conversation.user2_id === req.user.userId;

      if (!isUser1 && !isUser2) {
        return res.status(403).json({ error: 'Non autorizzato' });
      }

      const query = `
        SELECT 
          m.id,
          m.sender_id,
          m.recipient_id,
          m.message,
          m.created_at,
          u.nome as sender_nome,
          u.cognome as sender_cognome,
          u.tavolo as sender_tavolo
        FROM messages m
        JOIN users u ON m.sender_id = u.id
        WHERE (m.sender_id = ? AND m.recipient_id = ?)
           OR (m.sender_id = ? AND m.recipient_id = ?)
        ORDER BY m.created_at ASC
      `;

      const user1 = conversation.user1_id;
      const user2 = conversation.user2_id;

      db.all(query, [user1, user2, user2, user1], (messagesErr, messages) => {
        if (messagesErr) {
          console.error('Errore recupero messaggi:', messagesErr);
          return res.status(500).json({ error: 'Errore server' });
        }

        // ðŸ”¥ MOD 2: Marca come letti i messaggi ricevuti dall'utente corrente
        db.run(
          'UPDATE messages SET is_read = 1 WHERE recipient_id = ? AND (sender_id = ? OR sender_id = ?) AND is_read = 0',
          [req.user.userId, user1, user2]
        );

        res.json({
          messages: messages || [],
          user1_revealed: conversation.user1_revealed,
          user2_revealed: conversation.user2_revealed,
          status: conversation.status,
          initiator_id: conversation.initiator_id
        });
      });
    }
  );
});
app.post('/api/admin/login', (req, res) => {
  const { username, password } = req.body;

  if (username === ADMIN_USERNAME && password === ADMIN_PASSWORD) {
    const token = jwt.sign({ role: 'admin' }, JWT_SECRET, { expiresIn: '24h' });
    res.json({ token });
  } else {
    res.status(401).json({ error: 'Credenziali non valide' });
  }
});

function authenticateAdmin(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Token mancante' });
  }

  jwt.verify(token, JWT_SECRET, (err, decoded) => {
    if (err || decoded.role !== 'admin') {
      return res.status(403).json({ error: 'Accesso negato' });
    }
    next();
  });
}

app.get('/api/admin/stats', authenticateAdmin, (req, res) => {
  db.get('SELECT COUNT(*) as total FROM users', [], (err, totalUsers) => {
    if (err) {
      return res.status(500).json({ error: 'Errore server' });
    }

    db.get('SELECT COUNT(*) as online FROM users WHERE logged_in = 1 AND datetime(last_activity, "+30 minutes") > datetime("now")', [], (err2, onlineUsers) => {
      if (err2) {
        return res.status(500).json({ error: 'Errore server' });
      }

      db.get('SELECT COUNT(*) as total FROM messages', [], (err3, totalMessages) => {
        if (err3) {
          return res.status(500).json({ error: 'Errore server' });
        }

        db.get('SELECT COUNT(*) as subscribed FROM users WHERE newsletter_accepted = 1', [], (err4, newsletter) => {
          if (err4) {
            return res.status(500).json({ error: 'Errore server' });
          }

          res.json({
            totalUsers: totalUsers.total,
            onlineUsers: onlineUsers.online,
            totalMessages: totalMessages.total,
            newsletterSubscribers: newsletter.subscribed
          });
        });
      });
    });
  });
});

app.get('/api/admin/users', authenticateAdmin, (req, res) => {
  const query = `
    SELECT 
      id, 
      nome, 
      cognome, 
      email, 
      telefono, 
      tavolo, 
      logged_in,
      privacy_accepted,
      newsletter_accepted,
      created_at,
      last_login,
      last_activity
    FROM users 
    ORDER BY created_at DESC
  `;

  db.all(query, [], (err, users) => {
    if (err) {
      console.error('Errore recupero utenti:', err);
      return res.status(500).json({ error: 'Errore server' });
    }

    res.json(users || []);
  });
});

app.delete('/api/admin/users/:userId', authenticateAdmin, (req, res) => {
  const { userId } = req.params;

  db.run('DELETE FROM messages WHERE sender_id = ? OR recipient_id = ?', [userId, userId], (err) => {
    if (err) {
      console.error('Errore eliminazione messaggi:', err);
      return res.status(500).json({ error: 'Errore server' });
    }

    db.run('DELETE FROM conversations WHERE user1_id = ? OR user2_id = ?', [userId, userId], (err2) => {
      if (err2) {
        console.error('Errore eliminazione conversazioni:', err2);
        return res.status(500).json({ error: 'Errore server' });
      }

      db.run('DELETE FROM users WHERE id = ?', [userId], function(err3) {
        if (err3) {
          console.error('Errore eliminazione utente:', err3);
          return res.status(500).json({ error: 'Errore server' });
        }

        if (this.changes === 0) {
          return res.status(404).json({ error: 'Utente non trovato' });
        }

        res.json({ message: 'Utente eliminato' });
      });
    });
  });
});

app.get('/api/admin/export-newsletter', authenticateAdmin, (req, res) => {
  db.all(
    'SELECT nome, cognome, email, telefono FROM users WHERE newsletter_accepted = 1 ORDER BY created_at DESC',
    [],
    (err, users) => {
      if (err) {
        console.error('Errore esportazione newsletter:', err);
        return res.status(500).json({ error: 'Errore server' });
      }

      let csv = 'Nome,Cognome,Email,Telefono\n';
      users.forEach(user => {
        csv += `"${user.nome}","${user.cognome}","${user.email}","${user.telefono || ''}"\n`;
      });

      res.setHeader('Content-Type', 'text/csv');
      res.setHeader('Content-Disposition', 'attachment; filename=newsletter-meeq.csv');
      res.send(csv);
    }
  );
});

app.get('/api/admin/server-ip', authenticateAdmin, (req, res) => {
  const os = require('os');
  const interfaces = os.networkInterfaces();
  let serverIp = '172.16.0.10';

  for (const name of Object.keys(interfaces)) {
    for (const iface of interfaces[name]) {
      if (iface.family === 'IPv4' && !iface.internal) {
        serverIp = iface.address;
        break;
      }
    }
  }

  res.json({ ip: serverIp, port: PORT });
});

setInterval(() => {
  const query = `
    UPDATE users 
    SET logged_in = 0 
    WHERE logged_in = 1 
      AND datetime(last_activity, '+30 minutes') < datetime('now')
  `;

  db.run(query, [], function(err) {
    if (err) {
      console.error('Errore cleanup utenti:', err);
    } else if (this.changes > 0) {
      console.log(`ðŸ§¹ Cleanup: ${this.changes} utenti disconnessi per inattivitÃ `);
    }
  });
}, 5 * 60 * 1000);

setInterval(() => {
  db.run('DELETE FROM pending_registrations WHERE expires_at < datetime("now")', [], function(err) {
    if (err) {
      console.error('Errore cleanup PIN:', err);
    } else if (this.changes > 0) {
      console.log(`ðŸ§¹ Cleanup: ${this.changes} PIN scaduti eliminati`);
    }
  });
}, 10 * 60 * 1000);

const server = app.listen(PORT, '0.0.0.0', () => {
  console.log('\nðŸš€ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('   MEEQ SERVER ATTIVO');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log(`ðŸ“± Locale:  http://localhost:${PORT}`);
  console.log(`ðŸŒ Network: http://172.16.0.10:${PORT}`);
  console.log(`ðŸ‘¨â€ðŸ’¼ Admin:   http://172.16.0.10:${PORT}/admin`);
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  console.log('âœ¨ Connetti. Scopri. Gioca.\n');
});

process.on('SIGTERM', () => {
  console.log('ðŸ›‘ SIGTERM ricevuto. Chiusura server...');
  server.close(() => {
    console.log('âœ… Server chiuso');
    db.close();
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('\nðŸ›‘ SIGINT ricevuto. Chiusura server...');
  server.close(() => {
    console.log('âœ… Server chiuso');
    db.close();
    process.exit(0);
  });
});
